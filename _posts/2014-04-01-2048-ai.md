---
layout: post
title: "2048 AI"
description: ""
category: 
tags: []
---

A couple of weeks ago, one intern of my team re-posted a game called 2048 into our wechat group. Soon we found we could not stop playing the game. And some of us started to post screenshots of scores we got in the game.  We made higher and higher scores and finally completed 2048 tiles one day later. But we didn't stop, we kept going and tried to accomplish even bigger tile than 2048.

So I thought about one question:

####What is the biggest possible tile that can be made in the game?

We know that two 2s can be merged to make a 4, and two 4s can be merged to make an 8. And eventually, any big tile is made out of basic tiles, i.e. 2s or 4s. And after reading a little bit of code of the game, I found that the basic tiles appearing on the board have 90% probability to be a 2 and 10% to be a 4.
Let's ignore 4s first. We assume all new tiles are 2s. So any big tile is made from a set of 2s, via a sequence of merges. E.g. a 16 is made out of eight 2s via 7 merges. I drew a tree to illustrate these merges for the 16:

![Merges for a 16-Tile]({{ site.url }}/assets/2048_prove.png)

The two 2s, tile A and tile B, happen to be the LAST pair of 2s merged in the game. We can always find such a pair of 2s in any tree for a 16 or other big tiles.

Consider the moment that tile A is merged(with B). We can find a path from A to the root R. And all tiles in the path except A don't exist at that moment. So, look at those tiles going to be merged with a tile in the path, i.e. the brothers of tiles in the path: tile B, D and E. Each of them either exists on the board, or will be made from some tiles existing on the board because all 2s in the tree except A and B have already been merged and new 2s coming out later will not be used to make the 16. In both cases, there is at least one tile existing on the board for each of them.
Now we can calculate the minimal number of slots on the board required to make a 16: 1 for A, 1 for B, 1 for D and 1 for E. That equals to the length of the path from A to the root!
Yes, generally the number of slots required to make a 2^N is N – the height of the 'merge' tree for 2^N.
So the 2048 game has 16 slots and can not make a 2^17 in any way.


Back to the original 2048 game, a basic tile has 10% possibility to be 4. With some similar analysis, we can know the 2048 game can not make a 2^18 even even if all basic tiles are 4s.

Knowing the biggest possible tile in the game won't help me play the game better. So I tried to implement a program to run the game for me.

####Implement a 2048 AI

I first wrote a C++ AI program for the game. As almost impossible to make a 2^16, every tile can be encoded in 4 bit and the whole board can be encoded in a 64bit integer. And I can use bitwise operations to simulate movements easily. But a C++ program can not run in browser. And it's not cool if it can not be showed to others. So I rewrote it with javascript.

I had not written any javascript code for such a problem requiring so much computing. I had planed to search at least 10 steps and use some kind of map to avoid duplicated computing. But at last, I found javascript is far slower than C++. So I only search 3 steps by default and keep the amount of computing in a reasonable range.

And I also found using javascript objects as maps to avoid duplicated computing actually hurt the performance. I removed all of the code used to memorize searching results and got about 1x improvement in speed.

Finally, after trying a couple of estimation functions, I made the AI program run pretty fast. In the chrome browser of my laptop, it usually spends less than 30 seconds to make a 2048. And it hardly fails to make a 2048 and often makes a 4096 or 8192. And I have even made a 16384!

####The AI algorithm

The code has only 116 lines. The basic idea is to find the movement direction on which the game can get the maximal expected score. It's expected score because a new basic can appear in any empty slot with the same possibility, and can be 2 or 4.

The algorithm is:

    Search(grid, step) {
      if (step == max_step)
        return Estimate(grid);
      best_score = -INFINITE;
      for (i = 0; i < 3; ++i) {
        [new_grid, score] = MoveLeft(grid);
        if (new_grid == grid) continue;
        k = CountEmptySlot(new_grid);
        if (k == 0) {
          score += HUGE_PENALTY;
        } else {
          for (j = 0; j < 15; ++j) {
            if (new_grid[j] is empty) {
              new_grid[j] = 2;
              score += 1 / k * 0.9 * Search(new_grid, step+1);
              new_grid[j] = 4;
              score += 1 / k * 0.1 * Search(new_grid, step+1);
              reset new_grid[j];
            }
          }
        }
        if (score > best_score) best_score = score;
        new_grid = Rotate(new_grid);
      }
      return best_score;
    }

Estimate() is to estimate the situation of a grid got after max_step movements. I tried a couple of functions. Finally, I found a pretty good function having a penalty equal to the sum of differences of adjacent tiles. I added the penalty to the 4x sum of all tiles to make the estimation score positive. And I later multiplied the estimation score with 2 to magnify the effects of the penalty.

I used a very large penalty(-10^20) for a dead state. It’s to make the program try its best to avoid dead state. Although it maybe over evaluates the dead state, I didn’t want any game to fail before making a 2048.

By default, the max_step is 3. But if the number of visited states is less than 10000, it will start a new search with max_step increased by 1. The program will keep searching more and more deeply until the number of visited states is larger than 10000. Unusually there are much fewer states can be reached in a bad situation than a good situation. So the program can do enough jobs when the game is in a bad situation and can also save time when the game goes well.
There are indeed some duplicated computing when searching again. But as the number of visited states increases exponentially with the depth, only a small portion of computing is duplicated.

####Link

The game I forked and added AI into is in: <http://sleepycoder.github.io/2048/>.
The AI code is in <http://sleepycoder.github.io/2048/ai.js>.
And I also made a [chrome extension for the AI](https://chrome.google.com/webstore/detail/2048-ai/ggiomnbaioeocdipdgfllknhkpcnggjk).

Finally, I posted a 70,000+ and later a 170,000+ in the group and successfully extinguished our enthusiasms for the game.

{% include JB/setup %}
